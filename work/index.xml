<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Work | </title>
    <link>/work/</link>
      <atom:link href="/work/index.xml" rel="self" type="application/rss+xml" />
    <description>Work</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 28 May 2019 00:00:00 -0500</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Work</title>
      <link>/work/</link>
    </image>
    
    <item>
      <title>Dimensionality: The more the better?</title>
      <link>/work/feature_selection/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 -0500</pubDate>
      <guid>/work/feature_selection/</guid>
      <description>

&lt;p&gt;In an attempt to understand any sort of phenomenon, when faced with many potential factors, we tend to stick to those indicating of having a closer relationship with the outcome. If you, unfortunately, have a case of the runs, a doctor might first check if you had anything odd to eat, presented any other symptoms or even ask for the dreaded stool test instead of requesting an invasive biopsy right of the bat. With this approach, we may be implicitly exercising the pertinent cliché popularized by Willian of Occam&amp;rsquo; (aka the principle of parsimony)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;ldquo;Entities should not be multiplied without necessity.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;ldquo;When presented with competing hypotheses that make the same predictions, one should select the solution with the fewest assumptions&amp;rdquo;. Going back to the diagnosis, a doctor probably would initially relate the case with a direct root cause, such as the shady meals you&amp;rsquo;ve been eating rather than a claim of colon cancer, since there may not be enough evidence to suggest it. (which can be tested much easier &lt;a href=&#34;https://plato.stanford.edu/entries/simplicity/&#34; target=&#34;_blank&#34;&gt;https://plato.stanford.edu/entries/simplicity/&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;p style=&#34;font-size:0.8em;&#34;&gt;Consider leaving a &lt;span style=&#34;text-shadow: none;&#34;&gt;&lt;a class=&#34;github-button&#34; href=&#34;https://github.com/GEIA-UFSC/feature_selection&#34; data-icon=&#34;octicon-star&#34; data-size=&#34;small&#34; data-show-count=&#34;true&#34; aria-label=&#34;Star this on GitHub&#34;&gt;Star&lt;/a&gt;&lt;script async defer src=&#34;https://buttons.github.io/buttons.js&#34;&gt;&lt;/script&gt;&lt;/span&gt; if this helps you.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Contemporary philosophers have tended to reinterpret OR as a principle of theory choice: OR implies that—other things being equal—it is rational to prefer theories which commit us to smaller ontologies. This suggests the following paraphrase of OR:&lt;/p&gt;

&lt;p&gt;(OR1) Other things being equal, if T1 is more ontologically parsimonious than T2 then it is rational to prefer T1 to T2.
What does it mean to say that one theory is more ontologically parsimonious than another? The basic notion of ontological parsimony is quite straightforward, and is standardly cashed out in terms of Quine&amp;rsquo;s concept of ontological commitment. A theory, T, is ontologically committed to Fs if and only if T entails that F&amp;rsquo;s exist (Quine 1981, pp. 144–4). If two theories, T1 and T2, have the same ontological commitments except that T2 is ontologically committed to Fs and T1 is not, then T1 is more parsimonious than T2. More generally, a sufficient condition for T1 being more parsimonious than T2 is for the ontological commitments of T1 to be a proper subset of those of T2. Note that OR1 is considerably weaker than the informal version of Occam&amp;rsquo;s Razor, OR, with which we started. OR stipulates only that entities should not be multiplied beyond necessity. OR1, by contrast, states that entities should not be multiplied other things being equal, and this is compatible with parsimony being a comparatively weak theoretical virtue.&lt;/p&gt;

&lt;p&gt;Since Occam&amp;rsquo;s Razor ought to be invoked only when several hypotheses explain the same set of facts equally well, in practice its domain will be very limited…[C]ases where competing hypotheses explain a phenomenon equally well are comparatively rare (Holsinger 1980, pp. 144–5).&lt;/p&gt;

&lt;h2 id=&#34;read-justifications-of-simplicity-https-plato-stanford-edu-entries-simplicity&#34;&gt;Read: Justifications of Simplicity &lt;a href=&#34;https://plato.stanford.edu/entries/simplicity/&#34; target=&#34;_blank&#34;&gt;https://plato.stanford.edu/entries/simplicity/&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;(&lt;a href=&#34;https://en.wikipedia.org/wiki/Minimum_description_length&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/Minimum_description_length&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
&lt;a&gt;&amp;nbsp;&amp;nbsp;What is a feature&lt;/a&gt;&lt;br /&gt;
&lt;/summary&gt;
&lt;i&gt;&lt;br&gt;In machine learning and pattern recognition, a &lt;strong&gt;feature&lt;/strong&gt; (or an attribute) is an individual measurable property or characteristic of a phenomenon being observed.&lt;a href=&#34;#References&#34;&gt;[1]&lt;/a&gt;&lt;/i&gt;
&lt;br&gt;
&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
So what if instead of diagnosing one patient, we took a step further and focus to find the factors linked to a disease, let&amp;rsquo;s say colon cancer. By constraining the problem to investigate only genetic traits this can even seem easier, since we are dealing with a bounded set of possibilities.  However, in this case the number of equally potential factors is such that impedes us humans to understand the big picture. A dataset mapping to colon cancer presents more than 2.000 characteristics, or features &lt;a href=&#34;#References&#34;&gt;[4]&lt;/a&gt;. And many other aplications in data analysis generally present equal or greater amounts of information.&lt;/p&gt;

&lt;p style=&#34;font-size:0.8em;&#34;&gt;2009: ImageNet - 14 million images with 256x256 pixels (+196k features) each, and more than 20,000 categories &lt;a style=&#34;font-size:0.6em;&#34; href=&#34;#References&#34;&gt;[2]&lt;/a&gt;&lt;/p&gt;
&lt;p style=&#34;font-size:0.8em;&#34;&gt;2010: The Wikipedia Corpus - almost 1.9 billion words from more than 4 million articles &lt;a style=&#34;font-size:0.6em;&#34; href=&#34;#References&#34;&gt;[3]&lt;/a&gt;&lt;/p&gt;
&lt;p style=&#34;font-size:0.8em;&#34;&gt;2011: Cancer detection based on gene expression (e.g.: Colon dataset - 2,000 features) &lt;a style=&#34;font-size:0.6em;&#34; href=&#34;#References&#34;&gt;[4]&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;

ImageNet: 256x256x3 = 196608

Wikipedia: 1.9 billion words, not distinct, of course - the Second Edition of the 20-volume Oxford English Dictionary, published in 1989, contains full entries for 171,476 words in current use, and 47,156 obsolete words.

The tendency for &#34;wider&#34; amounts of information has increase over the years, probably related to our increase in storage and processing capabilties. We can observe this trend in a UBC dataset survey. Before the 2000s, very few domains operated with more than 40 features and soon after we have more than XX.


&lt;center&gt;&lt;img width=&#34;800&#34; src=&#34;./figures/number_of_attributes_growth.png&#34;/&gt;&lt;/center&gt;
&lt;p style=&#34;font-size:0.6em; text-align:right&#34;&gt;Source: &lt;a href=&#34;#References&#34;&gt;[5]&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-the-problem&#34;&gt;2. The problem&lt;/h1&gt;

&lt;p style=&#34;font-size:0.6em; text-align:right&#34;&gt;2. The problem&lt;/p&gt;
&lt;h3&gt;Too many features, too many problems&lt;/h3&gt;
&lt;p style=&#34;font-size:0.8em&#34;&gt;&lt;i&gt;What problems arise with too many features?&lt;/i&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;require longer training times*&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jeopardize human interpretability*&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;worsen prediction quality due to sample size effects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;potentially increase overfitting&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p style=&#34;font-size:0.6em; text-align:right&#34;&gt;* Considered self-explainatory, will not be further explained&lt;/p&gt;

&lt;h4&gt;3. Worsen prediction quality due to sample size effects&lt;/h4&gt;
&lt;p style=&#34;font-size:0.8em&#34;&gt;&lt;i&gt;Couldn&#39;t a predictor simply disregard irrelevant features?&lt;/i&gt;&lt;/p&gt;

---

To answer this, we will have to resort to some statistical learning theory, exploring the ways of estimating functional dependency from a given collection of data.

&lt;h5&gt;Statistical Learning Theory&lt;/h5&gt;

Let $$X \in \mathbb R^p$$ be a input random vector and $Y\in \mathbb R$ be an output random variable, with joint distribution $P(X,Y)$.

The task of learning aims at finding a function $f(X)$ for predicting $Y$ given values of input $X$. This structure requires a *loss function* $L(Y, f(X))$ for identifying and penalizing errors in prediction. With this structure, we can define a criterion for choosing a suitable $f$ known as the *Statistical Risk ($R$)*.

$$
\begin{equation}
\begin{split}
\text{R}(f) &amp; =  \mathbb{E} \thinspace L(Y, f(X)) \\
 &amp; = \int L(y, f(x))\thinspace P(dx,dy) \\
 &amp; = \mathbb{E}_{X}\mathbb{E}_{Y|X} [L(Y, f(X))|X]
\end{split}
\end{equation}
$$


&lt;p style=&#34;text-align:right;&#34;&gt;Source: &lt;a href=&#34;#References&#34;&gt;[5]&lt;/a&gt;&lt;/p&gt;

This criterion tells us how well, on average, the predictor $f$ performs with respect to the chosen loss function

Instead of working with the joint distribution, we can condition the Statistical Risk on $X$

$$
\begin{equation}
\begin{split}
\text{R}(f) &amp; = \int\int [L(y, f(x))|x]\thinspace P(dy)\thinspace P(dx) \\
 &amp; = \mathbb{E}_{X}\mathbb{E}_{Y|X} [L(Y, f(X))|X]
\end{split}
\end{equation}
$$

Finally, what we seek is a $f(X)$ which minimizes the the Risk:
&lt;br&gt;

$$f(X)_{opt}= argmin_c \mathbb{E}_{X}\mathbb{E}_{Y|X}[L(Y,c)|X]$$


The optimal solution will be different depending on the metric used

&lt;h5&gt;Regression&lt;/h5&gt;
&lt;h6&gt;Mean Squared Error (MSE)&lt;/h6&gt;
&lt;br&gt;

$$
\begin{equation}
\begin{split}
f(X)_{opt} &amp; = argmin_c \mathbb{E}_{X}\mathbb{E}_{Y|X}[(Y-c)^2|X] \\
 &amp; = \mathbb{E}(Y|X=x)
\end{split}
\end{equation}
$$

known as the conditional mean or expectation - the &#34;average&#34; value over an arbitrarily large number of occurrences
&lt;h6&gt;Mean Absolute Error (MAP)&lt;/h6&gt;
&lt;br&gt;

$$
\begin{equation}
\begin{split}
f(X)_{opt} &amp; = argmin_c \mathbb{E}_{X}\mathbb{E}_{Y|X}[|Y-c|\thinspace|X] \\
 &amp; = median(Y|X=x)
\end{split}
\end{equation}
$$

or the conditional median of the distribution


&lt;h3&gt;Regression loss functions for SLT&lt;/h3&gt;

**MSE**: the most preferable option, due to its ease of computation of minimum, since it is differentiable. However it is more sensitive to outliers as a big difference becomes even larger by squaring them. 

**MAP**: its optimal estimates are more robust than those for the conditional mean. However, MAP has discontinuities in their derivatives, which have hindered their widespread use.

&lt;h5&gt;Classification&lt;/h5&gt;
&lt;h6&gt;0-1 loss&lt;/h6&gt;

$$
\begin{equation}
\begin{split}
f(X)_{opt} &amp; = argmin_c \mathbb{E}_{X}\mathbb{E}_{Y|X}[I(f(X),Y)] \\
 &amp; = \underset{y \in Y}{\max}P(y|X)
\end{split}
\end{equation}
$$

where ${\displaystyle I}$ is the indicator function:

$$I :=\begin{cases}
0\text{, if } f(X) = Y\\
1\text{, otherwise}\\
\end{cases}$$

The decider is also known as the *Optimal Bayes classifier* (revise this).

If the joint probability $P(X,Y)$ is known and the classification decision is optimal.
&lt;center&gt;&lt;img src=&#34;./figures/bayes_error.svg&#34; width=&#34;900&#34; align=&#34;center&#34;/&gt;&lt;/center&gt;
This doesn&#39;t mean that there are no errors, rather than the lowest error achievable, resulted by noise among distributions.

If the probability distribution for the problem was known, the classifier wouldn&#39;t be affected by adding more of features.

If such features carried the slightest contributions, it is shown that the Bayes optimal classifier tends to zero as the number of features approach infinity.

&lt;center&gt;&lt;img src=&#39;./figures/trunk.png&#39; width=&#34;800&#34;/&gt;&lt;/center&gt;

However, the probability distribution used is an estimation, based on the finite set of samples, causing a **peaking phenomenon**: the prediction accuracy increases with the number of features, but soon reaches a peak, in which the noise becomes larger than the separability increase caused by the new feature.
&lt;p style=&#34;font-size:0.6em; text-align:right;&#34;&gt;Source: &lt;a href=&#34;#References&#34;&gt;[6]&lt;/a&gt;&lt;/p&gt;

This is often called the peaking phenomenon. Some ideas evolved around it are discussed in the great pattern recognition blog by Ela Pekalska and Bob Duin called [37steps](http://37steps.com/about/):
 - [Peaking summarized](http://37steps.com/2545/peaking-summarized/)
 - [Peaking paradox](http://37steps.com/2279/the-peaking-paradox/)
 - [Trunk’s example of the peaking phenomenond](http://37steps.com/2448/trunks-example/)
 - [The curse of dimensionality](http://37steps.com/2349/curse-of-dimensionality/)
 

&lt;h4&gt; 4. potentially increase overfitting&lt;/h4&gt;

&lt;p&gt;As the number of features increase, the observations become more sparse within the feature space.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&#39;./figures/exp_curse_of_overfitting.svg&#39; width=&#34;1500&#34;/&gt;
        &lt;/td&gt;&lt;br /&gt;
        &lt;td style=&#34;font-size:3em; width: 700px; word-wrap: break-word;&#34;&gt;
            &lt;p&gt;Having the observations further apart makes it difficult for the estimator to generalize, increasing its variance, i.e. relying on the specific observations to produce new predictions, causing overfitting.&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;Consequences for classical:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Non-parametric (Local methods)&lt;/strong&gt;: methods such as the $k$ &lt;em&gt;nearest neighboors&lt;/em&gt;, as the examples become increasingly sparse, the approximation of the conditional expectation by taking the average of its nearest neighboors becomes correspondingly worse as the query point distance itself from the known examples. Additionally, in high dimensions, as the datapoints become more spread apart, their distances become more uniform, making it dificult for the algorithm to decide which data points are more relevant to region of interest &lt;a href=&#34;https://www.youtube.com/watch?v=dZrGXYty3qc&amp;amp;list=PLXP3p2MXX_ahmhsMiP5YWtc7IcABeFOGH&amp;amp;index=2&#34; target=&#34;_blank&#34;&gt;Source&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parametric methods&lt;/strong&gt;:  In very high dimensional spaces, there is more than one plane that can be fitted to your data, and without proper type of regularization can cause the model to behave very poorly. . Collinearity often results in overfitting, i.e. in a too efficient modelling of learning samples without model generalization ability. [[7]]()&lt;/p&gt;

&lt;p&gt;More examples on  check the answer on &lt;a href=&#34;https://stats.stackexchange.com/questions/186184/does-dimensionality-curse-effect-some-models-more-than-others&#34; target=&#34;_blank&#34;&gt;stackexchange&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What causes these problems?&lt;/p&gt;

&lt;p style=&#34;font-size:0.8em; text-align:right&#34;&gt;&lt;i&gt;The curse of dimensionality&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;The curse of dimensionality&lt;/h3&gt;
&lt;br&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&#39;./figures/exp_curse_of_dimensionality.svg&#39; width=&#34;700&#34;/&gt;
        &lt;/td&gt;&lt;br /&gt;
        &lt;td style=&#34;font-size:3em; width: 700px; word-wrap: break-word;&#34;&gt;
            &lt;p&gt;Increasing the number of factors to be taken into consideration requires an exponential growth of observations &lt;a href=&#34;#References&#34;&gt;[5]&lt;/a&gt;&lt;br&gt;&lt;br&gt;
           However, having a small number of samples means that many regions of the feature space are never observed&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;h1&gt;&lt;a name=&#34;References&#34;&gt;&lt;/a&gt;References&lt;/h1&gt;
&lt;br&gt;
&lt;p style=&#34;font-size:0.6em;&#34;&gt;
&lt;a href=&#34;https://www.amazon.com/Pattern-Recognition-Learning-Information-Statistics/dp/0387310738&#34;&gt;[1]&lt;/a&gt;    : Bishop, C. (2006). Pattern recognition and machine learning&lt;br&gt;
&lt;a href=&#34;http://jmlr.csail.mit.edu/papers/volume3/guyon03a/guyon03a.pdf&#34;&gt;[2]&lt;/a&gt;    : Guyon, I. and Elissee, A. (2003). An Introduction to Variable and Feature Selection&lt;br&gt;
&lt;a href=&#34;http://image-net.org/challenges/LSVRC/&#34;&gt;[3]&lt;/a&gt;: Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla, A., Bernstein, M., C. Berg, A. and Fei-Fei, L. (2015) ImageNet Large Scale Visual Recognition Challenge. IJCV, 2015&lt;br&gt;
&lt;a href=&#34;https://snap.stanford.edu/data/wiki-meta.html&#34;&gt;[4]&lt;/a&gt;:Kossinets, G. (2010). Processed Wikipedia Edit History. Stanford large network dataset collection&lt;br&gt;
&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3287491/&#34;&gt;[5]&lt;/a&gt;: Liu, Q., Sung, A. H., Chen, Z., Liu, J., Chen, L., Qiao, M., Deng, Y. (2011). Gene selection and classification for cancer microarray data based on machine learning and similarity measures.&lt;br&gt;
&lt;a href=&#34;https://www.springer.com/gp/book/9780387848570&#34;&gt;[6]&lt;/a&gt;: Hastie, T., Tibshirani, R., and Friedman, J. H. (2009). The elements of Statistical learning: data mining, inference, and prediction.&lt;br&gt;
&lt;a href=&#34;https://ieeexplore.ieee.org/document/4766926&#34;&gt;[7]&lt;/a&gt;: Trunk, G. V. (1979). A Problem of Dimensionality: A Simple Example&lt;br&gt;
    &lt;a href=&#34;https://link.springer.com/chapter/10.1007/11494669_93&#34;&gt;[8]&lt;/a&gt;: Verleysen, M. and François, D. (2005). The Curse of Dimensionality in Data Mining and Time Series Prediction&lt;br&gt;
     &lt;a href=&#34;   http://papers.nips.cc/paper/2020-on-discriminative-vs-generative-classifiers-a-comparison-of-logistic-regression-and-naive-bayes.pdf&#34;&gt;[9]&lt;/a&gt;: Ng, A. Y. and Jordan, M. I. (2001). On Discriminative vs. Generative Classifiers: A comparison of logistic regression and naive Bayes&lt;br&gt;
     &lt;a href=&#34;   https://arxiv.org/abs/1601.07996&#34;&gt;[10]&lt;/a&gt;: Li, J., Cheng, K., Wang, S., Morstatter, F., Trevino, R. P., Tang, J., and Liu, H. (2017). Feature Selection: A Data Perspective&lt;br&gt;
    &lt;a href=&#34;   https://www.sciencedirect.com/science/article/pii/S1088467X97000085&#34;&gt;[11]&lt;/a&gt;: Dash, M. and Liu, H. (1997). Feature selection for classification&lt;br&gt;
    &lt;a href=&#34;https://www.researchgate.net/publication/2771488_Feature_Subset_Selection_as_Search_with_Probabilistic_Estimates&#34;&gt;[12]&lt;/a&gt;: Kohavi, R. (1994). Feature Subset Selection as Search with Probabilistic Estimates&lt;br&gt;
    &lt;a href=&#34;https://www.researchgate.net/publication/288257551_Feature_selection_for_classification_A_review&#34;&gt;[13]&lt;/a&gt;: Tang, J., Alelyani, S., Liu, H. (2014). Feature selection for classification: A review&lt;br&gt;
    &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S0304397597001151&#34;&gt;[14]&lt;/a&gt;: Amaldi,E., Kann, V. (1998). On the approximability of minimizing nonzero variables or unsatisfied relations in linear systems&lt;br&gt;
    &lt;a href=&#34;https://dl.acm.org/citation.cfm?id=2577699&#34;&gt;[15]&lt;/a&gt;:Chandrashekar, G., Sahin, F. (2014). A survey on feature selection methods&lt;br&gt;
      &lt;a href=&#34;https://ieeexplore.ieee.org/document/1674939/&#34;&gt;[16]&lt;/a&gt;: Narendra, P. M., Fukunaga, K. (1977). A Branch and Bound Algorithm for Feature Subset Selection&lt;br&gt;
          &lt;a href=&#34;https://www.amazon.com/Modern-Heuristic-Search-Methods-Rayward-Smith/dp/0471962805&#34;&gt;[17]&lt;/a&gt;: Rayward-Smith, V., Osman, I., Reeves, C. D., Smith, G. (1996). Modern Heuristic Search Methods&lt;br&gt;
      &lt;a href=&#34;https://bib.irb.hr/datoteka/763354.MIPRO_2015_JovicBrkicBogunovic.pdf&#34;&gt;[18]&lt;/a&gt;: Jović, A., Brkić, K., and Bogunović, N. (2015). A review of feature selection methods with applications&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deep learning challenges: saturation</title>
      <link>/work/saturation/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 -0500</pubDate>
      <guid>/work/saturation/</guid>
      <description>

&lt;p&gt;&lt;style&gt;
    h1 {
        text-align: left;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body {
    text-align: justify;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/style&gt;
 &lt;!-- This series intend to shed some light onto the problems that have followed the development of machine learning, and especially deep learning. I don&#39;t intend to make this a comprehensive review of all problems and corresponding techniques, whether to select some of the prominent obstacles. --&gt;&lt;/p&gt;

&lt;p&gt;The role of a machine learning system is to approximate a mapping between inputs and outputs using data and optimally generalize this behavior for unseen instances of the same problem.&lt;/p&gt;

&lt;p&gt;On this matter, several distinct strategies within artificial intelligence once had their share of success. In the past these were mainly supported by expert knowledge - either by embedding rigid rules into models or by manually combining input variables and designing more abstract features to mitigate limitations of the settings then used. At the same time, neural network models were able to determine target function solely based on the input data. The traditional setting of this model relied on a shallow structure, i.e. a small number of layers, and its achievements were subordinate to a simple set of applications.&lt;/p&gt;

&lt;!-- https://rinuboney.github.io/2015/10/18/theoretical-motivations-deep-learning.html
    http://videolectures.net/deeplearning2015_bengio_theoretical_motivations/ --&gt;

&lt;div&gt;
    &lt;img src=&#34;https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/img/spiral.1-2.2-2-2-2-2-2.gif&#34; width=&#34;50%&#34; align=&#34;left&#34;/&gt;
    &lt;img src=&#34;https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/img/spiral.2.2-2-2-2-2-2-2.gif&#34; width=&#34;50%&#34; align=&#34;right&#34;/&gt;
    &lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Combination of features to generate a linearly-separable decision space. On the left a two-layer network successfully separating the two classes. On the right a similar setting in which the same network fails.&lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Olah, C. (2016)&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;As the complexity of applications increase the mentioned approaches tend to fail. A task such as image classification pose a challenge to these methods namely because it is overwhelmingly difficult to combine a large number of low-level features (pixels) to determine a contrasting abstract outcome (object). Alternatively, deep learning is able to better accomplish this task (&lt;a href=&#34;#References&#34;&gt;Bradley (2010, pg. 22)&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Hierarchical learning, deep structured learning, or simply deep learning can be defined as &lt;em&gt;a class of machine learning techniques that exploit many layers of non-linear units&lt;/em&gt; (&lt;a href=&#34;#References&#34;&gt;Deng and Yu (2013, pg. 199)&lt;/a&gt;). This better capability is attained by the substantial coupling of non-linear operations whose parameters readapt, gradually approximating the target function thus deriving complex feature hierarchies from low-level inputs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/deep_learning_pg6.png&#34; width=&#34;60%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Compositional representation of features throughout layers: from pixels to gradients and edges. &lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Goodfellow et al. (2016, pg. 6)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;A neural network can progressively synthesize more structured features along layers, indicating the the number of layers as crucial factor in model design, and as research outlines in &lt;a href=&#34;#References&#34;&gt;He et al. (2015, pg. 2)&lt;/a&gt; and &lt;a href=&#34;(#References)&#34; target=&#34;_blank&#34;&gt;Krizhevsky et al. (2012, pg. 1)&lt;/a&gt; acknowledge performance improvement upon network depth increase.&lt;/p&gt;

&lt;p&gt;Still, how many layers are necessary to well approximate a function?
It turns out that the absolute number of layers is not the important factor, rather how many of these are necessary to effectively represent the target function, denominated as the &lt;em&gt;compact representation&lt;/em&gt; . Conversely, if a configuration is smaller than the compact representation, that can pose a predicament to the performance, as &lt;a href=&#34;(#References)&#34; target=&#34;_blank&#34;&gt;Bengio (2009, pg. 9)&lt;/a&gt; describes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;More precisely, functions that can be compactly represented by a depth $k$ architecture might require an exponential number of computational elements to be represented by a depth $k-1$ architecture. Since the number of computational elements one can afford depends on the number of training examples available to tune or select them, the consequences are not just computational but also statistical: poor generalization may be expected when using an insufficiently deep architecture for representing some functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, ideally, a function require a number of layers to be represented in efficient manner. However, in theory, that does not imply any counterpoints to stacks of layers greater than required by the function,as the spare layers could simply replicate the last compact representation output. However, many challenges arise as the depth of networks increase.&lt;/p&gt;

&lt;hr /&gt;

&lt;p style=&#34;font-size:0.6em;&#34;&gt;Consider leaving a &amp;nbsp&lt;span style=&#34;text-shadow: none;&#34;&gt;&lt;a class=&#34;github-button&#34; href=&#34;https://github.com/artur-deluca/artur-deluca.github.io&#34; data-icon=&#34;octicon-star&#34; data-size=&#34;small&#34; data-show-count=&#34;true&#34; aria-label=&#34;Star this on GitHub&#34;&gt;Star&lt;/a&gt;&lt;script async defer src=&#34;https://buttons.github.io/buttons.js&#34;&gt;&lt;/script&gt;&lt;/span&gt; &amp;nbsp if this helps you.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Despite the remarked capacity, deep architectures were not widely researched in the past as today. The reasons for this may encompass a the former contemptuous view of researchers on this topic, or an insufficient computational power especially compared to contemporary standards. This, however, will not be covered in this study. The challenges of employing such architectures were also posed by the difficulty in training neural networks with more than two layers, ultimately delivering poor generalization (Bengio et al. (2007))&lt;sup&gt;1&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a&gt;&lt;sup&gt;&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
&lt;p style=&#34;font-size:0.6em;&#34;&gt;
[1] &lt;a href=&#34;#References&#34;&gt;Bengio (2009, pg. 24)&lt;/a&gt; appropriately points that Convolutional Neural Networks with up to seven layers did not suffer as other types of models. This may be due to what the author denominates as a Topographic Structure, suggesting that each neuron in a layer is associated with a small portion of the input. From this, two favorable aspects are hypothesized: the gradient is propagated in a less diffuse way and this hierarchical local connectivity structure may be more suited for image recognition tasks, which is the most common use for such architecture.
&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;problem-layer-saturation&#34;&gt;Problem: Layer saturation&lt;/h3&gt;

&lt;p&gt;In the early development of neural networks, the initialization of parameters was performed by sampling a uniform distribution bounded to a predetermined interval. In this process, the weights and biases produced solutions that would generally lie far from optimum set of parameters, requiring many training iterations to readjust. Shallow networks did not suffer too much from this due to the smaller number of parameters, hence presenting an easier system to optimize. However, as the depth of networks increased, so did the difficulty to train such models using this initialization procedure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#References&#34;&gt;Glorot and Bengio (2010)&lt;/a&gt; promoted a study to understand why random initialization performed so poorly in deep networks. In this investigation, the authors considered one common initialization heuristic, introduced by LeCun et al. (1998), that defines the biases at 0 and the weights via sampling according to the following distribution:&lt;/p&gt;

&lt;p&gt;$$W_{ij}\sim U\left[-\frac{1}{\sqrt{n}},\frac{1}{\sqrt{n}}\right]$$&lt;/p&gt;

&lt;p&gt;where $n$ is the number of inputs to the unit. The authors then verified that in deep configurations of 4 to 5 layers, activation values on the last layers got stuck in plateaus situated at the extremes of the activation function, instance otherwise known as saturation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/saturation.png&#34; width=&#34;80%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Saturation regions on the sigmoid function. In the case observed by &lt;a href=&#34;#References&#34;&gt;Glorot and Bengio (2010)&lt;/a&gt;, the saturation occurred in the 5th and last layer of the network, with activation values converging to zero.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;One hypothesized explanation for saturation on sigmoid-equipped deep networks is that the random initialization does not provide useful information to the last layer of the network, that starts to rely more on its biases, which, in turn, are trained faster than its weights.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/saturation_plot.png&#34; width=&#34;100%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Mean (&lt;i&gt;lines&lt;/i&gt;) and standard deviation (&lt;i&gt;vertical bars&lt;/i&gt;) of sigmoid activation values across layers in a neural network using random initialization. The saturation is detectable in the last layer, where the activation values reach virtually zero. &lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Glorot and Bengio (2010)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Gradually but rapidly, the error gradient tends to push the activations towards zero in an attempt to suppress the influence of the previous layers. Eventually, the saturation may be overcome but the overall result would be of poor generalization.&lt;/p&gt;

&lt;h3 id=&#34;solution-unsupervised-pre-training&#34;&gt;Solution: Unsupervised pre-training&lt;/h3&gt;

&lt;p&gt;Layer saturation was the biggest technical hurdle that limited the progress of deep learning in the dawn of the millennium. In 2006, however, &lt;a href=&#34;#References&#34;&gt;Hinton et al. (2006)&lt;/a&gt; inspired by a well-established procedure, developed a novel approach to initialize the parameters of a Deep Belief Network — a class of neural networks — what in time overcame the saturation issue and surpassed performance ever seen using deep architectures. These results not only re-sparked but drastically expanded researchers interest in this field.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/deep_belief_net.svg&#34; width=&#34;80%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;A Deep Belief Network (DBN) can be seen as a stack of smaller unsupervised learning algorithms named Restricted Boltzmann Machines. This configuration can then be bundled with a classical multi-layer perceptron for supervised learning tasks&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;This initialization procedure encompassed an unprecedented process: an unsupervised greedy layer-wise pre-training step.&lt;sup&gt;2&lt;/sup&gt; Preceding the conventional supervised training, each layer is trained with its anterior neighboring layer identically to a Restricted Boltzmann Machine. This process starts with the input and first layer, and progressively advance one layer at a time until it sweeps all layers.&lt;/p&gt;

&lt;p&gt;A Boltzmann Machine is an unsupervised generative algorithm that learns the data representation by associating the patterns identified in the inputs to probabilistic configurations within its parameters. A Restricted Boltzmann Machine is a variation of such a model that reproduces a similar behavior but with significantly fewer connections.&lt;/p&gt;

&lt;p style=&#34;font-size:0.6em;&#34;&gt;
[2] Despite the imprecision, unsupervised pre-training is here used interchangeably
&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/BM_RBM.svg&#34; width=&#34;80%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;A Boltzmann Machine (&lt;i&gt;left&lt;/i&gt;) and a Restricted Boltzmann Machine (&lt;i&gt;right&lt;/i&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Many other unsupervised pre-training algorithms were developed concomitantly or immediately after, such as autoencoders &lt;a href=&#34;#References&#34;&gt;(Bengio et al. (2007))&lt;/a&gt;, denoising autoencoders &lt;a href=&#34;#References&#34;&gt;(Vincent et al. (2008))&lt;/a&gt;, contractive autoencoders &lt;a href=&#34;#References&#34;&gt;(Rifai et al. (2011))&lt;/a&gt;, among others.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/pretraining_improvement_comparison.png&#34; width=&#34;100%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Comparison of performance between networks running without pre-training (&lt;i&gt;left&lt;/i&gt;) and with pre-training (&lt;i&gt;right&lt;/i&gt;) &lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Erhan et al. (2010, pg. 636)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Why does this unsupervised learning methods help training deep architectures? Much of the explanation remains uncertain. Nonetheless, &lt;a href=&#34;#References&#34;&gt;Erhan et al. (2010)&lt;/a&gt; provide some clarifications through considerable experimentation. The claims of the authors reside on two possible, but not mutually exclusive reasons: &lt;i&gt;optimization&lt;/i&gt; and &lt;i&gt;regularization&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Deep neural networks are composed of many parameters whose values are used to compute an approximation of a function. Due to its substantial nonlinear nature, this approximation yields a non-convex function that poses a challenge on searching the best combination of weights and biases.&lt;sup&gt;3&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/convex_nonconvex.png&#34; width=&#34;100%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;A convex (left) and non-convex (right) function. Note that, contrarily to the convex function, the non-convex function possesses multiple local optima. Source: &lt;a href=&#34;#References&#34;&gt;Zadeh (2016)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p style=&#34;font-size:0.6em;&#34;&gt;
[3] Many discussions today in academia evolve around the particular shape of loss landscape in deep neural networks, since many of the local minima appear to have equally good qualities, suggesting that the critical solutions reached during training are actually saddle points. This discussion will be reserved to further studies.
&lt;/p&gt;

&lt;p&gt;Gradient-based methods employed in training eventually converge to their pre-selected basin of attraction, a region of the function space, such that any point in it eventually is iterated into the attractor. Unsupervised pre-training may work towards optimization by favoring a basin of attraction that might yield a lower training error. Thus, since the gradients are very prompt to abrupt changes, backpropagation is only used at a local search level, from an already favorable starting point (&lt;a href=&#34;#References&#34;&gt;Hinton (2012, lecture 14b)&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;As for &lt;i&gt;regularization&lt;/i&gt;, one may commonly associate it with explicit techniques, such as the L1 or L2 norm:&lt;/p&gt;

&lt;p&gt;$$C=-\frac{1}{n}\sum_{j}\left[y_j\ln a_j^{L}+\left(1-y_j\right)\ln\left(1-a_j^{L}\right)\right]+\frac{\lambda}{2n}\sum_iw_i{{}^2}$$&lt;/p&gt;

&lt;p&gt;By adding the &lt;i&gt;L2 regularization&lt;/i&gt; factor in the cross-entropy cost function, presented in the equation above, one can penalize overly complex models, that would result in poor generalization, i.e. &lt;i&gt;high testing error&lt;/i&gt;. However, the regularization employed by pre-training is implicit. In attempt to model how such technique would work explicitly, &lt;a href=&#34;#References&#34;&gt;Erhan et al. (2009)&lt;/a&gt; defines a regularization term such as:&lt;/p&gt;

&lt;p&gt;$$regularizer=-log\,P\left(\theta\right)$$&lt;/p&gt;

&lt;p&gt;The function $P\left(\theta\right)$ describes the probability that the weights of the neural network are initialized as $\theta$. So, if a configuration shows to be highly improbable, the regularizer term will hurt the cost function strongly. Furthermore, if the probability of landing such set of parameters is high, the regularizer will then reward the cost function. This probability is governed by the initialization methods employed. Considering two instances with and without pre-training, we obtain:&lt;/p&gt;

&lt;p&gt;$$P_{{\text{pre-training}}}(\theta) = \sum_k\frac{1_{\theta \in R_k}\pi_k}{v_k}$$&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;$$P_{{\text{no pre-training}}}(\theta) = \sum_k\frac{1_{\theta \in R_k}r_k}{v_k}$$&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
where $R_k$ is the basin of attraction that contains $\theta$, and $1_{\theta \in R_k}$ is the identifier function – unitary for all $\theta$ in $R_k$, otherwise null. Additionally, $\pi_k$ and $r_k$ are the probabilities of landing in the basin of attraction $R_k$, which has a volume $v_k$. Since the basins of attraction are disjunct sets, the probability density function of the set of parameters located in $R_k$ is uniform, calculated by taking the probability of landing in the k-th basin ($\pi_k$ or $r_k$) and dividing by its volume.&lt;/p&gt;

&lt;p&gt;Pre-training the parameters of the network conditions the network initialization to land on regions of better generalization. This is hypothetically achieved by increasing the $\pi_k$&amp;rsquo;s where the network parameters represent meaningful variations of the input, contributing to predict the output. For this reason, pre-training also reduces the variance upon parameter initialization.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/trajectories.png&#34; width=&#34;70%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;2-D visualization of parameters&amp;rsquo; trajectory of 100 neural networks with and without the unsupervised pre-training step. The color gradient from dark-blue to cyan symbolizes the progression of iterations. &lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Erhan et al. (2010, pg. 541)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;The visualization of the parameters&amp;rsquo; trajectory may demonstrate the effects of optimization and regularization. As mentioned through the former, it may select a basin of attraction with lower training errors. Conversely, regularization may bound the parameter interval to a range that yields good generalization. Also, it is crucial to notice that both training and testing errors collected in the experiments of &lt;a href=&#34;#References&#34;&gt;Erhan et al. (2010)&lt;/a&gt; support these hypotheses, but do favor the latter.&lt;/p&gt;

&lt;p&gt;Furthermore, once established within the solution space, the parameters do not drastically change during the gradient-based adjustment process. In fact, this process is also denominated fine-tuning, as it only modifies the features slightly to get the category boundaries, rather than discovering new relationships (&lt;a href=&#34;#References&#34;&gt;Hinton (2012, lecture 14b)&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/trained_filters.svg&#34; width=&#34;90%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Visualization of filters of a Deep Belief Network used to recognize digits form the MNIST data-set after the different training processes; from left to right: units from the first, second and third layers, respectively. &lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Erhan et al. (2010, pg. 638-639)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;But how can one conceptually understand the effects of unsupervised learning? Apart from regularization and optimization hypothesis, the layer-wise pre-training resembles the underlying distribution of the input. Ideally, this representation, by combining the different features and mapping their inner relationships, can unveil, and more importantly, disentangle causal elements that influence the output. If those inputs can be transformed in uncorrelated features, it is possible to solve for a particular parameter disregarding its influence over the others.&lt;/p&gt;

&lt;p&gt;As mentioned in &lt;a href=&#34;#References&#34;&gt;Goodfellow et al. (2016, pg. 541)&lt;/a&gt;, this hypothesis justify approaches in which one first seeks a good representation for $p(x)$ before training with the output. If the output is closely related to factors captured by the input, an initialization that captures the distribution of x is useful for predicting the desired output distribution $p\left(y|x\right)$.&lt;/p&gt;

&lt;p&gt;However, despite the aforementioned advantages, unsupervised pre-training presents noteworthy drawbacks, such as establishing two separate learning stages (unsupervised and supervised). As a consequence, there is a long delay between adjusting hyperparameters on the first stage utilizing feedback from the second. Additionally, although pre-training being considered a valuable regularizer, its strength adjustment is troublesome, requiring a somewhat unclear modification of far too many hyperparameters — contrasting with explicit regularization techniques that can be adjusted by a single one.&lt;/p&gt;

&lt;p&gt;For the above mentioned reasons, unsupervised pre-training is not so popularly used today, as other techniques discovered produced the same benefits much more efficiently. These will be explained in the following post, where these strategies will also tackle a different obstacle: Vanishing gradients.&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;&lt;a name=&#34;References&#34;&gt;&lt;/a&gt;References&lt;/h2&gt;
&lt;ul style=&#34;font-size:0.6em;&#34;&gt;
    &lt;li&gt;Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends in Machine Learning. 1-127.&lt;/li&gt;
    &lt;li&gt;Bengio, Y., Lamblin, P., Popovici, D., and Larochelle, H. (2007). Greedy Layer-Wise Training of Deep Networks. In Advances in Neural Information Processing Systems 19, 153-160.&lt;/li&gt;
    &lt;li&gt;Bradley, D. M. (2010). Learning In Modular Systems. PhD Thesis, Carnegie Mellon University.&lt;/li&gt;
    &lt;li&gt;Olah, C. (2014). Neural Networks, Manifolds, and Topology. Colah&amp;rsquo;s blog&lt;/li&gt;
    &lt;li&gt;Deng, L. and Yu, D. (2013). Deep Learning: Methods and Applications.
    Foundations and Trends in Signal Processing, 7-197.&lt;/li&gt;
    &lt;li&gt;Erhan, D., Bengio, Y., Courville, A., Manzagol, P.A., Vincent, P., and Bengio, S. (2010). Why Does Unsupervised Pre-training Help Deep Learning? Journal of Machine Learning Research, 11-36.&lt;/li&gt;
    &lt;li&gt;Erhan, D., Manzagol, P.A., Bengio, Y., Bengio, S., and Vincent, P. (2009). The Difficulty of Training Deep Architectures and the Effect of Unsupervised Pre-Training. Artificial Intelligence and Statistics, 153-160.&lt;/li&gt;
    &lt;li&gt;Glorot, X. and Bengio, Y. (2010). Understanding the diffculty of training deep feedforward neural networks. Proceedings of the Thirteenth International Conference on Artificial Intelligence and
    Statistics , pages 249-256.&lt;/li&gt;
    &lt;li&gt;Goodfellow, I., Bengio, Y., and Courville, A. (2016). Deep Learning. MIT Press.&lt;/li&gt;
    &lt;li&gt;He, K., Zhang, X., Ren, S., and Sun, J. (2015). Deep Residual Learning for Image Recognition. Proceedings of the IEEE conference on computer vision and pattern recognition.&lt;/li&gt;
    &lt;li&gt;Hinton, G. (2012). Neural Networks for Machine Learning. Coursera Online Course.&lt;/li&gt;
    &lt;li&gt;Hinton, G. E., Osindero, S., and Teh, Y.-W. (2006). A Fast Learning Algorithm for Deep Belief Nets. Neural Computation , 1527-1554.&lt;/li&gt;
    &lt;li&gt;Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). ImageNet Classification with Deep Convolutional Neural Networks. Advances in Neural Information Processing Systems 25, 1097-1105.&lt;/li&gt;
    &lt;li&gt;LeCun, Y. A., Bottou, L., Orr, G. B., and Müller, K.-R. (1998). Efficient BackProp. Neural Networks: Tricks of the Trade, 9-48.&lt;/li&gt;
    &lt;li&gt;Rifai, S., Vincent, P., Muller, X., Glorot, X., and Bengio, Y. (2011).
    Contractive Auto-encoders: Explicit Invariance During Feature Extraction. Proceedings of the 28th International Conference
    on Machine Learning, 833-840.&lt;/li&gt;
    &lt;li&gt;Vincent, P., Larochelle, H., Bengio, Y., and Manzagol, P.-A. (2008).
    Extracting and Composing Robust Features with Denoising Autoencoders. Proceedings of the 25th International Conference, 1096-1103.&lt;/li&gt;
    &lt;li&gt;Xu, B., Huang, R., and Li, M. (2016). Revise Saturated Activation Functions.&lt;/li&gt;
    &lt;li&gt;Zadeh, R. (2016). The hard thing about deep learning. O&amp;rsquo;Reilly Media.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Obstacles along deep learning evolution: vanishing gradients</title>
      <link>/work/vanishing_gradients/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 -0500</pubDate>
      <guid>/work/vanishing_gradients/</guid>
      <description>

&lt;style&gt;
body {
text-align: justify}
&lt;/style&gt;

&lt;p&gt;The objective of this series is to illustrate some of the past and on-going challenges within deep learning. In the previous blog post, the obstacle discussed was the &lt;a href=&#34;../saturation&#34;&gt;saturation&lt;/a&gt; within activation functions during training. This is a follow-up, so I recommend you take a brief look before continuing.&lt;/p&gt;

&lt;!--
## The challenges of training deep networks
Despite mentioning pre-training as solution for saturation, such technique is not employed as much today. This is due to fact that the properties that pre-training ensures can be attained by a much more efficient strategy which will be explained further on. 

https://arxiv.org/pdf/1504.06825.pdf
--&gt;

&lt;h3 id=&#34;problem-vanishing-gradients&#34;&gt;Problem: Vanishing gradients&lt;/h3&gt;

&lt;p&gt;As mentioned in the previous post, the activation values start to migrate towards the extremities of the sigmoid function in networks with several layers. But what happens to the gradients? Around the 1980&amp;rsquo;s researchers at USC and CMU started to work on algorithms using the gradient of the loss function throughout the layers of the network as a way to adjust each weight with a corresponding &amp;ldquo;influence&amp;rdquo; over the error. These gradients were obtained analytically by applying the chain rule from the loss function to the desired weight. This is famously called the backpropagation technique, and has spurred the development of neural networks later on. (Cite hinton 1989)&lt;/p&gt;

&lt;p&gt;However, once again, as the stack of layers increase, obstacles arise to  hamper performance, and this time this is caused by a phenomenon known as the Vanishing/Exploding Gradients. To illustrate it, consider a network with a general cost function and symmetric activation functions $f$ with unit derivative at 0. If we write $a_{i}$ for the activation vector of layer $i$, and $s_{i}$ the argument vector of the activation function at layer $i$, we have $s_{i}=a_{i}W_{i}+b_{i}$ and $a_{i}=f(s_{i})$.&lt;/p&gt;

&lt;p&gt;Consider the following node output and activation:&lt;/p&gt;

&lt;p&gt;Consider the following node output and activation:&lt;/p&gt;

&lt;p&gt;$$s^{i}=W^{i}a^{i-1}+b_{i}$$&lt;/p&gt;

&lt;p&gt;$$a_{i+1}=g\left(W_{i}a_{i-1}+b_{i}\right)$$&lt;/p&gt;

&lt;p&gt;The derivative of the loss function $\mathcal{L}$ in a network with $l$ layers in terms of a weight $W_{n}$ can be written as:&lt;/p&gt;

&lt;p&gt;$$\frac{\partial\mathcal{L}}{\partial W_{n}}=\frac{\partial s_{n}}{\partial W_{n}}\left[\underset{i=n}{\overset{l-1}{\prod}}\frac{\partial a_{i+1}}{\partial s_{i}}\frac{\partial s_{i+1}}{\partial a_{i+1}}\right]\frac{\partial a_{l}}{\partial s_{l}}\frac{\partial\mathcal{L}}{\partial a_{l}}$$&lt;/p&gt;

&lt;p&gt;Defining a linear activation function $g(z_{i})=z_{i}$ and $W_{i}=W$, we obtain:&lt;/p&gt;

&lt;p&gt;$$\require{cancel}\frac{\partial\mathcal{L}}{\partial W_{n}}=\frac{\partial s_{n}}{\partial W_{n}}\left[\underset{i=n}{\overset{l-1}{\prod}}\cancelto{1}{\frac{\partial a_{i+1}}{\partial s_{i}}}\cancelto{W}{\frac{\partial s_{i+1}}{\partial a_{i+1}}}\right]\frac{\partial a_{l}}{\partial s_{l}}\frac{\partial\mathcal{L}}{\partial a_{l}}$$&lt;/p&gt;

&lt;p&gt;Thus:&lt;/p&gt;

&lt;p&gt;$$\frac{\partial\mathcal{L}}{\partial W_{n}}=a_{n-1}W^{n-l}\frac{\partial\mathcal{L}}{\partial a_{l}}$$&lt;/p&gt;

&lt;p&gt;So, in deep configurations, the backpropagation technique may become troublesome as a result of exploding or vanishing gradients. As the cost function is progressively derived in terms of numerically large parameters, these adjustments will likely overshoot, hampering training. Conversely, small contributions propagated through many layers may cause virtually no effect at all:&lt;/p&gt;

&lt;p&gt;Moreover, in deep configurations, the backpropagation technique may become troublesome as a result of exploding or vanishing gradients. As the cost function is progressively derived in terms of numerically large parameters, these adjustments will likely overshoot, hampering training. Conversely, small contributions propagated through many layers may cause virtually no effect at all:&lt;/p&gt;

&lt;p&gt;If the elements in W greater than one, and with a sufficiently large n-l value, $\frac{\partial\mathcal{L}}{\partial W_{n}}$ will tend to infinity, i.e. exploding. Conversely, for values less than one, the derivative tends to zero, i.e. vanishing.&lt;/p&gt;

&lt;p&gt;For the case of early neural network development, a typical initialization framework presented in Erhan et al. (2009) would have parameters randomly sampled from a uniform distribution centered in zero of $[-1/\sqrt{k};1/\sqrt{k}]$ where k is the size of the previous layer of a fully-connected network. For deep architectures, many nodes would likely be initialized very close to zero, leading to the previously mentioned vanishing gradient problem. Bradley (2010, pg. 25) provides an interesting illustration of this, by analyzing the distribution of weights in the initialization of the network. As the number of layers increased, the weights got significantly peaked around zero, thus evidenciating the cause of the issue.&lt;/p&gt;

&lt;h3 id=&#34;activation-functions-and-initialization-methods&#34;&gt;Activation functions and initialization methods&lt;/h3&gt;

&lt;p&gt;In the following course of deep learning development, improvements introduced into networks&amp;rsquo; training and architecture led to the near abandonment of the very one technique that resurged attention onto the field: unsupervised pre-training. Such advances were a combination of modern activation functions and simpler but sophisticated initialization methods. These also helped to mitigate the vanishing gradient problem. But appart from the ackowledged need for better alternatives to pre-training, what is the problem of using the once well-adopted activation function: the sigmoid? By exploring different functions, it became apparent that the activation was one of the main contributors to the saturation issue, demonstrated through research conducted by Glorot and Bengio (2010)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./figures/saturation_plot.png&#34; width=&#34;100%&#34;/&gt;
&lt;p style=&#34;font-size:0.8em;&#34; align=&#34;center&#34;&gt;Mean (&lt;i&gt;lines&lt;/i&gt;) and standard deviation (&lt;i&gt;vertical bars&lt;/i&gt;) of sigmoid activation values across layers in a neural network using random initialization. The saturation is detectable in the last layer, where the activation values reach virtually zero. &lt;br&gt;Source: &lt;a href=&#34;#References&#34;&gt;Glorot and Bengio (2010)&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;A technique employed way before such improvements although is goes along with them are the old standardizing of inputs and parameters. LeCun et al. (1998) points out that rescaling the input reducing its mean to 0 and variance to 1 may help training. The first prevents undiserable bias towards particular directions, making it less sensible to the distinc features scales while it also prevents undesirable uniform gradient updates if the majority of the input data where of the same sign. The latter helps to even the contributions from all features, balancing the rate at which the weights connected to the input nodes learn. Additionally it also helps to not saturate too early and does not go straight to zero. Such techniques are not only important on the inputs as they are desirable characteristics for each layer within the network. So, preserving the variance throughout layers during training is a desirable property. Additionally from the backpropagation point of view, the variance of the derivative of the cost function by the weights is equally important to be mantained.&lt;/p&gt;

&lt;p&gt;Nevertheless, expanding on &lt;a href=&#34;#References&#34;&gt;Glorot and Bengio (2010&lt;/a&gt; work, &lt;a href=&#34;#References&#34;&gt;Xu et al. (2016)&lt;/a&gt; draws theorical clues to indicate that in its linear regime, in comparison with other activation functions, the sigmoid is more prone to escalating the variance of layers througout training.&lt;/p&gt;

&lt;p&gt;Considering the following notation:&lt;/p&gt;

&lt;p&gt;$$s^i=f\left(s^{i-1}\right)W^i+b^i$$&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;$$a^{i+1}=f\left(a^{i}W^{i}+b^{i}\right)$$&lt;/p&gt;

&lt;p&gt;where $f(s)$ and $s$ are the activation function and its argument vector, respectively; $a$ is the activation value, $W\in\mathbb{R}^{{n_i\times n_{i-1}}}$ the weight matrix and $b\in \mathbb{R}^{n_i}$ the bias vector. In a linear regime, the activation function can be modeled as:&lt;/p&gt;

&lt;p&gt;$$f(s)=\alpha s+\beta$$&lt;/p&gt;

&lt;p&gt;Assuming that, similar to the intialization presented in [eq:1], biases are set to 0, the variance at layer i can be defined as:&lt;/p&gt;

&lt;p&gt;$$Var\left[a^{i}\right]=\alpha{{}^2}n_i\sigma_{i-1}^{2}\left(Var\left(a^{i-1}\right)+\beta{{}^2}I_{n_i}\right)$$&lt;/p&gt;

&lt;p&gt;Likewise, the gradient variance, comprised during the backwards pass, is defined as:&lt;/p&gt;

&lt;p&gt;$$Var\left(\frac{\partial cost}{\partial a^{i-1}}\right)=\alpha{{}^2}n_i\sigma_{i-1}^{2}Var\left(\frac{\partial cost}{\partial a^{i}}\right)$$&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&#34;#References&#34;&gt;Glorot and Bengio (2010)&lt;/a&gt;, preserving the variance throuhgout layers and iterations is an indication that the information is flowing without loss. Furthermore, it is evident that as the variance increase, the more the activation values resort to the function&amp;rsquo;s extremes, resulting in saturation. Thus, ideally:&lt;/p&gt;

&lt;p&gt;$$Var\left(y^{i}\right)=Var\left(y^{i-1}\right)\text{ and }Var\left(\frac{\partial cost}{\partial y^{i}}\right)=Var\left(\frac{\partial cost}{\partial y^{l-1}}\right)$$&lt;/p&gt;

&lt;p&gt;assuming $n_{i}\sigma_{i-1}^{2}\approxeq1$ and $n_{i-1}\sigma_{i-1}^{2}\approxeq 1$. So, to satisfy this condition $\alpha$ and $\beta$ must be:&lt;/p&gt;

&lt;p&gt;$$\alpha=1\text{ and }\beta=0$$&lt;/p&gt;

&lt;p&gt;Considering the Taylor expansions of different activation functions:&lt;/p&gt;

&lt;p&gt;$$sigmoid(x)=\frac{1}{2}+\frac{x}{4}-\frac{x^{3}}{48}+O\left(x^{5}\right)$$&lt;/p&gt;

&lt;p&gt;$$tanh(x)=0+x+\frac{x^{3}}{3}+O\left(x^{5}\right)$$&lt;/p&gt;

&lt;p&gt;This approximation indicates, that in the linear regime, the tanh function satisfies the condition $\alpha=1$ while the sigmoid posesses a constant term that may explain the increase in variance throughout the feedfoward propagation. Additionally, due to the significantly small slope in comparison with the tanh, the sigmoid function requires a weight initialization 16 times greater ($\alpha^{2}$) than the tanh to maintain the gradient variance (&lt;a href=&#34;#References&#34;&gt;Xu et al. (2016)&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;h1&gt;&lt;a name=&#34;References&#34;&gt;&lt;/a&gt;References&lt;/h1&gt;
&lt;ul style=&#34;font-size:0.8em;&#34;&gt;
    &lt;li&gt;Bradley, D. M. (2010). Learning In Modular Systems. PhD Thesis, Carnegie Mellon University.&lt;/li&gt;
    &lt;li&gt;Erhan, D., Manzagol, P.A., Bengio, Y., Bengio, S., and Vincent, P. (2009). The Difficulty of Training Deep Architectures and the Effect of Unsupervised Pre-Training. Artificial Intelligence and Statistics, 153-160.&lt;/li&gt;
    &lt;li&gt;Glorot, X. and Bengio, Y. (2010). Understanding the diffculty of training deep feedforward neural networks. Proceedings of the Thirteenth International Conference on Artificial Intelligence and
    Statistics , pages 249-256.&lt;/li&gt;
    &lt;li&gt;Goodfellow, I., Bengio, Y., and Courville, A. (2016). Deep Learning. MIT Press.&lt;/li&gt;
    &lt;li&gt;LeCun, Y. A., Bottou, L., Orr, G. B., and Müller, K.-R. (1998). Efficient BackProp. Neural Networks: Tricks of the Trade, 9-48.&lt;/li&gt;
    &lt;li&gt;Shanmugamani, R. (2018). Deep Learning for Computer Vision.&lt;/li&gt;
    &lt;li&gt;Xu, B., Huang, R., and Li, M. (2016). Revise Saturated Activation Functions.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
