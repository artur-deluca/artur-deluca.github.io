[{"authors":["admin"],"categories":null,"content":"arturbackdeluca [at] gmail [dot] com\nI am a master's student in Artificial Intelligence and Robotics at the University of Rome. I am currently looking for research programs involving questions of statistical learning and optimization within (but not restricted to) deep learning. Please feel free to reach me via any of the digital mediums here available. I currently live in Rome, but I\u0026rsquo;m originally from Brazil. My favorite activities are listening to unfamiliar genres of music and running, although usually not at the same time 😃.\n ","date":1554595200,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://artur-deluca.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"arturbackdeluca [at] gmail [dot] com\nI am a master's student in Artificial Intelligence and Robotics at the University of Rome. I am currently looking for research programs involving questions of statistical learning and optimization within (but not restricted to) deep learning. Please feel free to reach me via any of the digital mediums here available. I currently live in Rome, but I\u0026rsquo;m originally from Brazil. My favorite activities are listening to unfamiliar genres of music and running, although usually not at the same time 😃.","tags":null,"title":"Artur de Luca","type":"authors"},{"authors":null,"categories":null,"content":" These series intend to shed some light on the problems and corresponding solutions that have followed the development of deep learning. I don\u0026rsquo;t intend to make this a comprehensive review of all techniques but to select some of the prominent ones.\n In the early development of neural networks, the initialization of parameters was performed by sampling a uniform distribution bounded to a predetermined interval. In this process, the weights and biases produced solutions that would generally lie far from an optimum set of parameters, requiring many training iterations to readjust. Shallow networks did not suffer too much from this due to the smaller number of parameters, hence presenting an easier system to optimize. However, as the depth of networks increased, so did the difficulty to train such models using this initialization procedure.\nGlorot and Bengio (2010) promoted a study to understand why random initialization performed so poorly in deep networks. In this investigation, the authors considered one common initialization heuristic, introduced by LeCun et al. (1998), that defines the biases at 0 and the weights via sampling according to the following uniform distribution:\n$$W_{ij}\\sim U\\left[-\\frac{1}{\\sqrt{n}},\\frac{1}{\\sqrt{n}}\\right]$$\nwhere $n$ is the number of inputs to the unit. The authors then verified that in deep configurations of 4 to 5 layers, activation values on the last layers got stuck in plateaus situated at the extremes of the activation function, a case otherwise known as saturation.\nSaturation regions on the sigmoid function. In the case observed by Glorot and Bengio (2010), the saturation occurred in the 5th and last layer of the network, with activation values converging to zero.\nOne hypothesis that explains saturation on sigmoid-equipped deep networks is that the random initialization does not provide useful information to the last layer of the network, that starts to suppress the previous contributions and rely more on its biases, which, in turn, are trained faster than its weights.\nMean (lines) and standard deviation (vertical bars) of sigmoid activation values across layers in a neural network using random initialization. The saturation is detectable in the last layer, where the activation values reach virtually zero. Source: Glorot and Bengio (2010)\nGradually but rapidly, the error gradient tends to push the activations towards zero in an attempt to suppress the influence of the previous layers. Eventually, the saturation may be overcome but the overall result would be of poor generalization.\nUnsupervised pre-training Layer saturation was one of the biggest technical hurdles that limited the progress of deep learning in the dawn of the millennium. However, in 2006, inspired by a well-established procedure, Hinton et al. (2006) developed a novel approach to initialize the parameters of a Deep Belief Network — a class of neural networks — that overcame the saturation issue and surpassed state of the art performance in deep architectures. These results not only re-sparked but drastically expanded researchers’ interest in this field.\nA Deep Belief Network (DBN) can be seen as a stack of smaller unsupervised learning algorithms named Restricted Boltzmann Machines. This configuration can then be bundled with a classical multi-layer perceptron for supervised learning tasks\nThis initialization procedure encompassed an unprecedented process: an unsupervised greedy layer-wise pre-training step1. Prior to the conventional supervised training, each layer is trained with its anterior neighboring layer identically to a Restricted Boltzmann Machine, using an unsupervised learning algorithm named Contrastive Divergence. This process starts with the input and first layer, and progressively advances one layer at a time until it sweeps all layers.\nA Boltzmann Machine is an unsupervised generative algorithm that learns the data representation by associating the patterns identified in the inputs to probabilistic configurations within its parameters. A Restricted Boltzmann Machine is a variation of such a model that reproduces a similar behavior but with significantly fewer connections.\n1 Despite the imprecision, unsupervised pre-training is here used interchangeably A Boltzmann Machine (left) and a Restricted Boltzmann Machine (right)\nMany other unsupervised pre-training algorithms were developed concomitantly or immediately after, such as autoencoders (Bengio et al. (2007)), denoising autoencoders (Vincent et al. (2008)), contractive autoencoders (Rifai et al. (2011)), among others.\nComparison of performance between networks running without pre-training (left) and with pre-training (right) Source: Erhan et al. (2010, pg. 636)\nWhy does this unsupervised learning methods help training deep architectures? Much of the explanation remains uncertain. Nonetheless, Erhan et al. (2010) provide some clarifications through considerable experimentation. The claims of the authors reside on two possible but not mutually exclusive reasons: optimization and regularization.\nDeep neural networks are composed of many parameters whose values are used to compute an approximation of a function. Due to its substantial nonlinear nature, this approximation yields a non-convex function that poses a challenge on searching the best combination of weights and biases.2\nA convex (left) and non-convex (right) function. Note that, contrarily to the convex function, the non-convex function possesses multiple local optima. Source: [Zadeh (2016)](#References)\n2 Many discussions today in academia evolve around the particular shape of loss landscape in deep neural networks, since many of the local minima appear to have equally good qualities, suggesting that the critical solutions reached during training are actually saddle points. This discussion will be reserved to further studies. Gradient-based methods employed in training eventually converge to their pre-selected basin of attraction, a region of the function space, such that any point in it eventually is iterated into the attractor (roughly speaking, a valley in the loss function). Unsupervised pre-training may work towards optimization by favoring a basin of attraction that might yield a lower training error. Thus, since the gradients are very prompt to abrupt changes, backpropagation is only used at a local search level, from an already favorable starting point (Hinton (2012, lecture 14b)).\nAs for regularization, one may commonly associate it with explicit techniques, such as the L1 or L2 norm:\n$$C=-\\frac{1}{n}\\sum_{j}\\left[y_j\\ln a_j^{L}+\\left(1-y_j\\right)\\ln\\left(1-a_j^{L}\\right)\\right]+\\frac{\\lambda}{2n}\\sum_iw_i{{}^2}$$\nBy adding the L2 regularization factor in the cross-entropy cost function, presented in the equation above, one can penalize overly complex models, that would result in poor generalization, i.e. high testing error. However, the regularization employed by pre-training is implicit. In attempt to model how such technique would work explicitly, Erhan et al. (2009) defines a regularization term such as:\n$$regularizer=-log\\thinspace P\\left(\\theta\\right)$$\nThe function $P\\left(\\theta\\right)$ describes the probability that the weights of the neural network are initialized as $\\theta$. So, if a configuration shows to be highly improbable, the regularizer term will hurt the cost function strongly. Furthermore, if the probability of landing such set of parameters is high, the regularizer will then reward the cost function. This probability is governed by the initialization methods employed. Considering two instances with and without pre-training, we obtain:\n$$P_{{\\text{pre-training}}}(\\theta) = \\sum_k\\frac{1_{\\theta \\in R_k}\\pi_k}{v_k}$$\nand\n$$P_{{\\text{no pre-training}}}(\\theta) = \\sum_k\\frac{1_{\\theta \\in R_k}r_k}{v_k}$$\nwhere $R_k$ is the basin of attraction that contains $\\theta$, and $1_{\\theta \\in R_k}$ is the identifier function – unitary for all $\\theta$ in $R_k$, otherwise null. Additionally, $\\pi_k$ and $r_k$ are the probabilities of landing in the basin of attraction $R_k$, which has a volume $v_k$. Since the basins of attraction are disjunct sets, the probability density function of the set of parameters located in $R_k$ is uniform, calculated by taking the probability of landing in the k-th basin ($\\pi_k$ or $r_k$) and dividing by its volume.\nPre-training the parameters of the network conditions the network initialization to land on regions of better generalization. This is hypothetically achieved by increasing the $\\pi_k$'s where the network parameters represent meaningful variations of the input, contributing to predict the output. For this reason, pre-training also reduces the variance upon parameter initialization.\n2-D visualization of parameters' trajectory of 100 neural networks with and without the unsupervised pre-training step. The color gradient from dark-blue to cyan symbolizes the progression of iterations. Source: Erhan et al. (2010, pg. 541)\nThe visualization of the parameters’ trajectory may demonstrate the effects of optimization and regularization. As mentioned through the former, it may select a basin of attraction with lower training errors. Conversely, regularization may bound the parameter interval to a range that yields good generalization. Also, it is crucial to notice that both training and testing errors collected in the experiments of Erhan et al. (2010) support these hypotheses, but do favor the latter.\nFurthermore, once established within the solution space, the parameters do not drastically change during the gradient-based adjustment process. This process is also denominated fine-tuning, as it only modifies the features slightly to get the category boundaries, rather than discovering new relationships (Hinton (2012, lecture 14b)).\nVisualization of filters of a Deep Belief Network used to recognize digits form the MNIST data-set after the different training processes; from left to right: units from the first, second and third layers, respectively.\nSource:Erhan et al. (2010, pg. 638-639)\nBut how can one conceptually understand the effects of unsupervised learning? Apart from the regularization and optimization hypothesis, the layer-wise pre-training resembles the underlying distribution of the input. Ideally, this representation, by combining the different features and mapping their inner relationships, can unveil, and more importantly, disentangle causal elements that influence the output. If those inputs can be transformed into uncorrelated features, it is possible to solve for a particular parameter disregarding its influence over the others.\nAs mentioned in Goodfellow et al. (2016, pg. 541), this hypothesis justify approaches in which one first seeks a good representation for $p(x)$ before training with the output. If the output is closely related to factors captured by the input, an initialization that captures the distribution of x is useful for predicting the desired output distribution $p\\left(y|x\\right)$.\nFurthermore, unsupervised pretraining can be related with the recent work of Schwartz-Ziv and Tishby (2017) on studying neural networks from an information theory perspective. Essentially, the authors claim that the learning process of a neural network model is based on the maximizing the mutual information between the inputs and the outputs. Mutual information can be defined as:\n$$I(X,Y) = H(X)-H(X|Y)$$\nwhere $H$ is the entropy of the variable $X$:\n$$H(X) = \\mathbb{E}[-\\log\\thinspace(P(X)]$$\nEntropy essentially measures the amount of information, i.e. the degree of uncertainty one has over a random variable. Moreover, when provided another random variable Y, we can measure the conditional entropy of X given Y:\n$$H(Y|X)=-\\sum _{x\\in {\\mathcal {X}},y\\in {\\mathcal {Y}}}p(x,y)\\log {\\frac {p(x,y)}{p(x)}} $$\nThus, mutual information is a statistical measurement between two random variables that indicate how much knowing one of these variables reduces uncertainty about the other. This, in turn, may have a connection with training neural networks as one begins the training stage knowing to little about the input and output, hence, having low mutual information stored in the neural network layers.\nMutual information measurements on 100-layer neural networks. Layer ordering ranges from green (initial layers) to orange (final layers). Source:Schwartz-Ziv and Tishby (2017)\nHowever, as the training phase starts, the layers slowing move towards higher mutual information over $X$ and then towards $Y$. What happens in principle is that in the beginning, the network layers learn different representations over the input space, which in turn carry a lot of information over the input, but also some information about the output. As the training phase continues, the network layers, particularly the deeper ones, then discard some of the irrelevant information of $X$ which is not predictive of $Y$.\nSnapshot of mutual information measurements along layers in different trainig epohcs. On the left, the neural network is at epoch zero, on the center at epoch 400, and the on right at epoch 9000. Source:Schwartz-Ziv and Tishby (2017)\nThe pretraining procedure can be related to the theory, particularly in the first part. By using an unsupervised learning algorithm, we may find a combination of parameters for each layer along with the network that shares higher mutual information with the input variable $X$ and consequently some with the output variable $Y$. As the gradient-based learning process continues, some of this information gets refined, as previously mentioned.\nHowever, despite the aforementioned advantages, unsupervised pre-training presents noteworthy drawbacks, such as establishing two separate learning stages (unsupervised and supervised). As a consequence, there is a long delay between adjusting hyperparameters on the first stage utilizing feedback from the second. Additionally, although pre-training being considered a valuable regularizer, its strength adjustment is troublesome, requiring a somewhat unclear modification of far too many hyperparameters — contrasting with explicit regularization techniques that can be adjusted by a single one.\nFor the reasons mentioned above, unsupervised pre-training is not so popularly used today, as other techniques discovered yielded the same benefits but much more efficiently. These will be explained in the following post, where these strategies will also tackle a different obstacle: vanishing gradients.\nReferences Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends in Machine Learning. 1-127. Bengio, Y., Lamblin, P., Popovici, D., and Larochelle, H. (2007). Greedy Layer-Wise Training of Deep Networks. In Advances in Neural Information Processing Systems 19, 153-160. Erhan, D., Bengio, Y., Courville, A., Manzagol, P.A., Vincent, P., and Bengio, S. (2010). Why Does Unsupervised Pre-training Help Deep Learning? Journal of Machine Learning Research, 11-36. Erhan, D., Manzagol, P.A., Bengio, Y., Bengio, S., and Vincent, P. (2009). The Difficulty of Training Deep Architectures and the Effect of Unsupervised Pre-Training. Artificial Intelligence and Statistics, 153-160. Glorot, X. and Bengio, Y. (2010). Understanding the diffculty of training deep feedforward neural networks. Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics , pages 249-256. Goodfellow, I., Bengio, Y., and Courville, A. (2016). Deep Learning. MIT Press. Hinton, G. (2012). Neural Networks for Machine Learning. Coursera Online Course. Hinton, G. E., Osindero, S., and Teh, Y.-W. (2006). A Fast Learning Algorithm for Deep Belief Nets. Neural Computation , 1527-1554. LeCun, Y. A., Bottou, L., Orr, G. B., and Müller, K.-R. (1998). Efficient BackProp. Neural Networks: Tricks of the Trade, 9-48. Rifai, S., Vincent, P., Muller, X., Glorot, X., and Bengio, Y. (2011). Contractive Auto-encoders: Explicit Invariance During Feature Extraction. Proceedings of the 28th International Conference on Machine Learning, 833-840. Vincent, P., Larochelle, H., Bengio, Y., and Manzagol, P.-A. (2008). Extracting and Composing Robust Features with Denoising Autoencoders. Proceedings of the 25th International Conference, 1096-1103. Zadeh, R. (2016). The hard thing about deep learning. O'Reilly Media. Schwartz-Ziv, R. and Tishby, N. (2017). Opening the black box of Deep Neural Networks via Information. Featured on: Why \u0026 When Deep Learning Works: Looking Inside Deep Learning. arXiv:1703.00810v3   h1 { text-align: left; } body { text-align: justify; }  ","date":1557378000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557378000,"objectID":"ce1023914d78fa1081a2443f70dd6539","permalink":"https://artur-deluca.github.io/post/pretraining/","publishdate":"2019-05-09T00:00:00-05:00","relpermalink":"/post/pretraining/","section":"post","summary":"These series intend to shed some light on the problems and corresponding solutions that have followed the development of deep learning. I don\u0026rsquo;t intend to make this a comprehensive review of all techniques but to select some of the prominent ones.\n In the early development of neural networks, the initialization of parameters was performed by sampling a uniform distribution bounded to a predetermined interval. In this process, the weights and biases produced solutions that would generally lie far from an optimum set of parameters, requiring many training iterations to readjust.","tags":[""],"title":"Deep learning advances: unsupervised pretraining","type":"post"},{"authors":null,"categories":null,"content":"In the last decade, there\u0026rsquo;s been a widespread interest in artificial intelligence, particularly machine learning, and even more specifically deep learning. Curiously, this topic has not only resurged within academia but rather it has also been commonly showcased on non-technical mediums.\nWhy these topics became so popular now? Certainly, recent feats such as AlphaGo or Waymo may raise awareness and hint to potential implications in our social organization, especially in the labor sector. Still, but what underlying technical advances have enabled these achievements - and what makes deep learning a paradigm so relevant within the past few years?\nIn the aforementioned fields, one common task is to reason upon prior knowledge to derive plausible conclusions, a task known as inference. On this matter, strategies within artificial intelligence like expert systems had shared some success by encapsulating an expert\u0026rsquo;s rationale into knowledge bases. These databases were then used by an inference engine, typically using logical rules, to reason out conclusions.\nHowever, as tasks grow in complexity, performance becomes hindered by computational limitations of reaching a decision using an inference engine in a large database. Not just that, but the lack of satisfactory techniques for reasoning under uncertainty was also an important obstacle that hampered the further development of expert systems (Heathfield (1999)).\nA different paradigm, brought forward by machine learning, is to derive the relationships needed for inference using observations. More importantly, these models must be able to generalize this behavior for unseen instances of the given problem. Oftentimes, these relationships within data can be quite convoluted and in recent decades, a class of learning algorithms came to attention by the ability to derive these mappings: local kernel methods.\nThis family of methods is a fairly recent grouping of techniques that have been developed independently for several years. They are called so due to the transformation performed so-called kernel function onto the input data, and some examples of models are Support Vector Machines, Gaussian processes, among other techniques. A local kernel method can be defined as:\n$$f(x) = b + \\sum^n_{i=1} \\alpha_iK_D\\left(x, x_i\\right)$$\nwhere $b$ is the bias term, $D$ is the set of observations of cardinality $n$, $α_i$ is scalar chosen by the learning algorithm upon $D$, $x_i$'s are the training input observations and $K_D$ is the kernel function. These methods are more effective than linear models by being able to generate more favorable representations of feature space by using kernels (usually non-linear), achieving fairly positive results in several applications.\n Transformation of features to generate a linearly-separable decision space. On the left the original dataset with two classes. On the right a transformation using PCA with a Gaussian kernel.\n One typical kernel function is the Gaussian kernel:\n$$K_\\sigma(u, v) = e^{-\\frac{\\left\\Vert u-v \\right\\Vert^2}{2\\sigma^{2}}}$$\nwhere $\\sigma^2$ is the equivalent of the variance in a gaussian probability density function. Note that the function is symmetric and as $u$ and $v$ become very distant from each other, the function approaches zero. This means that for the estimation of a query point $u$, the neighboring values of $u$ have much more influence than those further away from it.\nAs postulated by David Wolpert in his no free lunch theorem, no model performs better than random guess without any kind of assumption. Local kernel methods are no exception: they implicitly or explicitly partition the input space, obtaining good generalization for a new query point by exploiting the training examples in its neighborhood. This comes at the price of the so-called smoothness prior, meaning that these models expect a target function with little variation of results among neighboring observations.\n We may insert additional priors through the choice of the kernel as well as the feature representation. This is why for these types of models it might be beneficial to generate alternative representations of the input data. Rather than using their raw representation, these modifications could more closely conform to the model smoothness prior, yielding better results. Although not targeted at handcrafting representations, Bengio et al. (2014) provides a thorough analysis of good characteristics for representations of features.\n However, for particular types of problems the smoothness assumption may not hold, posing a predicament to this family of methods. As an illustration, consider the task of recognizing a character from a $\\texttt{20×20}$ pixel grid. If we consider the number of variations of a simple horizontal translation, we notice that a particular observation of the letter $O$ has much more similarity with the letter $U$ in the exact position and orientation that the same letter $O$ shifted horizontally, for instance.\nDemonstrations of the amount of variation among observations inter and intra-class.\nThis indicates that the target function may not be as smooth as expected. In this highly non-linear function, local kernel methods require a very large number of training examples to cover all the desired variations within a class. Hence, the number of necessary templates can grow exponentially with the intrinsic dimension of a class manifold (Bengio and Lecun (2007)).\nThe set of observations associated with the same class forms a manifold or a set of disjoint manifolds, i.e. regions of lower dimension than the original space of images. When this manifold is smooth, it can be approximated locally by linear patches, tangent to the manifold. However, as the manifold becomes irregular and highly dimensional, patches become smaller and exponentially many patches, as well as data, are required to obtain a good generalization. Source: Bengio (2009)\nNote that this does not confront the ability of local kernel methods to approximate functions, rather their efficiency on approximating a function in regards to data. By contrast, neural network models are capable of dealing with intra-class variations more effortlessly. While each kernel function is activated in a small area of the input space, feature detectors of neural networks are capable of detecting certain patterns (edges or curvatures) almost independently from its orientation. The combination of these feature detectors is what makes neural network representations so efficient.\nAs an illustration, consider the task of representing a number from 0-7. The representation generated by local methods can be seen as a one-hot encoding, signaling that each representation is mutually exclusive, for instance, $\\texttt{0000001}$ signals $1$ and $\\texttt{0000010}$ signals $2$ but the representation $\\texttt{0000011}$ does not convey any valid information. Conversely, a representation of a neural network can be seen as a binary representation, much more efficient: $\\texttt{001}$ is equal to $1$, $\\texttt{010}$ to 2 and $\\texttt{011}$ to $3$.\nIn terms of classification, local methods produce mutually exclusive partitions onto the feature space which it oftentimes makes it difficult to generalize for unseen instances of the problem, if the target function is not smooth. On the other hand, neural networks generate several partitions which are compositional, presenting a more efficient decision surface that can be more robust to unseen query points.\nSketch of a partition of the feature space produced by local methods (left) and neural networks (right). Note that the sub-partitions of the right figure can be combined to infer unseen instances of the problem, represented by the symbol $?$. These sub-partitions can be seen as potential explanatory factors. As an illustration, these can be the color, shape, and texture in the task of detecting particular types of fruits. Conversely, the partitions on the left symbolize specific combinations of these factors that can indicate a certain fruit. Source: Bengio (2009)\nThe set of tasks illustrated so far are relatively simple in comparison to those that we see today, as in multi-class object detection. In previous decades, these simpler tasks were carried out relying on a shallow neural network architecture, i.e. using only a small number of layers. However, as the complexity of applications increase, this approach tends to fail.\nComplex image classification tasks, for instance, pose a challenge to these methods namely because it becomes overwhelmingly difficult to combine a larger number of low-level features (pixels) to determine a contrasting abstract outcome (object). Alternatively, deep learning is able to better accomplish this task (Bradley (2010, pg. 22)), as experimental outlines in He et al. (2015) and Krizhevsky et al. (2012) indicate breakthrough performances upon increase in network depth.\nResults of the 2012 ImageNet classification competition. Only the first out of 5 top models was a deep neural network, which achieved unprecedented performance. Source: ImageNet\nHierarchical learning, deep structured learning, or simply deep learning can be defined as a class of machine learning techniques that exploit many layers of non-linear units (Deng and Yu (2013, pg. 199)). This better capability is attained by the substantial coupling of non-linear operations, deriving complex feature hierarchies from low-level inputs.\nCompositional representation of features throughout layers: from pixels to gradients and edges. Source: Goodfellow et al. (2016, pg. 6)\nAs illustrated, different representations are synthesized along the layers and as representations become more related to the task in hand, the better the model can perform. However, how many layers are necessary to well approximate a function? In reality, the absolute number of layers is not the important factor, rather how many of these are necessary to effectively represent the target function, denominated as the compact representation. Moreover, if a configuration is smaller than the compact representation, that can generate a negative effect on performance.\nIt turns out that a configuration with one layer less than the compact representation may need an exponential number of neurons to achieve the same performance. This can be illustrated by the awarded work of Håstad (1986). By analogy, if we consider neural networks as simple logic circuits (which they are able to emulate), we can observe that a logic architecture limited in-depth presents an exponential number of components in comparison with a deep counterpart. Consider the calculation of the parity function, defined as:\n$$f:\\{0,1\\}^{n}\\rightarrow\\{0,1\\},\\thinspace f(x)=\\left(\\overset{|x]}{\\underset{i=1}{\\sum}}x_{i}\\right) mod\\space 2$$\nThe number of logical components for a depth-limited architecture of 2 layers and $N$ inputs is of an order of $O(2^{N})$. On the other hand, unbounded architectures can produce less complex systems, such as the daisy-chain structure of complexity $O(N\\thinspace log\\thinspace N)$.\nDistinct architectures to compute the parity function. A Disjunctive normal form structure (left) with a complexity of $2^{N-1}$ and a balanced tree structure (right) with 5 layers and complexity of $O(N\\thinspace log\\thinspace N)$.\nConversely, what could happen when freely adding more layers? In principle, besides the additional computational cost, this would not imply any counterpoints to approximating the target function, since the spare layers could simply replicate the second-to-last representation output. However, as in the shallow case, the model may carry too many parameters and insufficient training examples. This, in turn, would have statistical drawbacks: instead of approximating the desired mapping, the model starts to memorize the training data, causing overfitting, i.e. poor generalization1.\nDespite the remarked capacity, deep architectures were not widely researched in the past as today. The reasons for this may encompass the former contemptuous view of researchers on this topic, or an insufficient computational power especially compared to contemporary standards. This, however, will not be covered in this series. The challenges of employing such architectures were also imposed by the difficulty in training neural networks with more than two layers, ultimately delivering poor generalization (Bengio et al. (2007))2.\nIn the next series of posts, I cover some of the improvements and predicaments that have followed the development of deep learning, starting from unsupervised pretraining.\n\n1 This is a generally accepted consequence of very deep models that do not have enough training observations. However, recent research by Nakkiran et al. points to a completely different direction [return]. \n2 Bengio (2009, pg. 24) appropriately points out that Convolutional Neural Networks with up to seven layers did not suffer as other types of models. This may be due to what the author denominates as a Topographic Structure, suggesting that each neuron in a layer is associated with a small portion of the input. From this, two favorable aspects are hypothesized: the gradient is propagated less diffusely and this hierarchical local connectivity structure may be more suited for image recognition tasks, which is the most common use for such architecture [return]. References Heathfield, H. (1999). The rise and “fall” of expert systems in medicine. Expert Systems. 183–188. Wolpert, D. (1996), The Lack of A Priori Distinctions between Learning Algorithms. Neural Computation, 1341-1390. Bengio, Y., Courville, A. and Vincent, P. (2014). Representation Learning: A Review and New Perspectives Bengio, Y. and LeCun, Y. (2007). Scaling Learning Algorithms towards AI. 41. Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends in Machine Learning. 1-127. Bengio, Y., Lamblin, P., Popovici, D., and Larochelle, H. (2007). Greedy Layer-Wise Training of Deep Networks. In Advances in Neural Information Processing Systems 19, 153-160. Bradley, D. M. (2010). Learning In Modular Systems. PhD Thesis, Carnegie Mellon University. Olah, C. (2014). Neural Networks, Manifolds, and Topology. Colah's blog Deng, L. and Yu, D. (2013). Deep Learning: Methods and Applications. Foundations and Trends in Signal Processing, 7-197. Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). ImageNet Classification with Deep Convolutional Neural Networks. Advances in Neural Information Processing Systems 25, 1097-1105. He, K., Zhang, X., Ren, S., and Sun, J. (2015). Deep Residual Learning for Image Recognition. Proceedings of the IEEE conference on computer vision and pattern recognition. Goodfellow, I., Bengio, Y., and Courville, A. (2016). Deep Learning. MIT Press.   h1 { text-align: left; } body { text-align: justify; }  ","date":1557378000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557378000,"objectID":"db2c395583a858dbdc3560de378bc21a","permalink":"https://artur-deluca.github.io/post/introduction/","publishdate":"2019-05-09T00:00:00-05:00","relpermalink":"/post/introduction/","section":"post","summary":"In the last decade, there\u0026rsquo;s been a widespread interest in artificial intelligence, particularly machine learning, and even more specifically deep learning. Curiously, this topic has not only resurged within academia but rather it has also been commonly showcased on non-technical mediums.\nWhy these topics became so popular now? Certainly, recent feats such as AlphaGo or Waymo may raise awareness and hint to potential implications in our social organization, especially in the labor sector.","tags":[""],"title":"Why deep learning became relevant","type":"post"},{"authors":["Artur de Luca"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"9ffae0391f44d5100ca140a95a65f56a","permalink":"https://artur-deluca.github.io/projects/psopt/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/projects/psopt/","section":"projects","summary":"A python package for discrete optimization using particle swarms","tags":["Source Themes"],"title":"PSOpt - Particle swarm optimizer","type":"projects"},{"authors":["Artur de Luca"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"fed0c9c05988ef91ee2d9b27ae4915d3","permalink":"https://artur-deluca.github.io/projects/landscapeviz/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects/landscapeviz/","section":"projects","summary":"Visualizing the loss landscape of fully connected neural networks using tensorflow","tags":["Source Themes"],"title":"Landscapeviz","type":"projects"},{"authors":["Artur de Luca"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"83b5f64f1df254e6591371fc835e7b23","permalink":"https://artur-deluca.github.io/projects/sac/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects/sac/","section":"projects","summary":"Implementation and evaluation of the Soft-Actor critic algorithm using MXNet and OpenAI Gym","tags":["Source Themes"],"title":"Soft Actor-Critic in MXNet","type":"projects"},{"authors":["Artur de Luca"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c6409b9d5307d1240a18cf8e19c426e7","permalink":"https://artur-deluca.github.io/projects/malware/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects/malware/","section":"projects","summary":"A general overview and illustration of static malware analysis and other malicious software inspection strategies.","tags":["Source Themes"],"title":"Static malware analysis","type":"projects"}]